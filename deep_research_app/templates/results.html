<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research: {{ topic }}</title> <!-- Display original topic -->
    <link rel="stylesheet" href="{{ pico_css }}">
    <style>
        /* --- NEW: Enable smooth scrolling for anchor links --- */
        html {
            scroll-behavior: smooth;
        }
        body { padding-top: 1rem; padding-bottom: 3rem; }
        main.container { max-width: 960px; }
        h1, h2, h3 { margin-bottom: 0.5rem; }
        hr { margin: 2rem 0; }
        #progress-log-container {
            max-height: 300px;
            overflow-y: auto;
            background-color: var(--pico-card-background-color);
            border: 1px solid var(--pico-card-border-color);
            padding: 1rem;
            border-radius: var(--pico-border-radius);
            margin-bottom: 1.5rem;
            font-size: 0.875em;
        }
        #progress-log { list-style: none; padding-left: 0; margin: 0; }
        #progress-log li { margin-bottom: 0.3rem; word-break: break-word; line-height: 1.4; }
        #progress-log li:first-child { font-weight: bold; }
        #progress-log li.error { color: var(--pico-form-invalid-color); font-weight: bold; }
        .stream-container {
            border: 1px dashed var(--pico-primary-focus);
            padding: 1rem;
            margin-top: 1rem;
            margin-bottom: 1.5rem;
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-contrast-hover);
            display: none;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 400px;
            overflow-y: auto;
            /* --- MODIFIED: Ensure wrapping for stream content --- */
            white-space: pre-wrap;    /* Wrap lines but preserve line breaks/spaces */
            word-wrap: break-word;    /* Force break long words/URLs */
            overflow-wrap: break-word;/* Alias for word-wrap, broader compatibility */
        }
        /* --- NEW: Explicitly target pre tags inside stream container --- */
        .stream-container pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            margin: 0; /* Remove default pre margin */
        }

        .stream-container h4 { margin-top: 0; color: var(--pico-primary); }
        #final-report-container { margin-top: 2rem; }
        #final-report-content {
            background-color: var(--pico-card-background-color);
            padding: 1.5rem;
            border-radius: var(--pico-border-radius);
            border: 1px solid var(--pico-card-border-color);
            /* --- NEW: Add wrapping for final report content --- */
            word-wrap: break-word;
            overflow-wrap: break-word;
         }
        #final-report-content h1, #final-report-content h2, #final-report-content h3 { margin-top: 1.5em; margin-bottom: 0.5em; border-bottom: 1px solid var(--pico-muted-border-color); padding-bottom: 0.2em; }
        #final-report-content h1:first-child, #final-report-content h2:first-child { margin-top: 0; }
        /* --- NEW: Add wrapping specifically for pre tags within final report --- */
        #final-report-content pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            background-color: var(--pico-contrast); /* Optional: Style code blocks */
            padding: 1em;
            border-radius: var(--pico-border-radius);
            overflow-x: auto; /* Add horizontal scroll if absolutely needed, but wrap preferred */
        }
        /* --- Modified footnote link style for better visibility --- */
        #final-report-content sup a {
            text-decoration: none;
            background-color: var(--pico-mark-background-color);
            color: var(--pico-mark-color); /* Ensure text color contrasts with background */
            padding: 2px 4px; /* Slightly more padding */
            border-radius: var(--pico-border-radius);
            font-size: 0.8em; /* Slightly smaller font */
            vertical-align: super; /* Ensure it stays superscript */
            transition: background-color 0.2s ease; /* Smooth transition */
        }
        #final-report-content sup a:hover, #final-report-content sup a:focus {
             background-color: var(--pico-primary); /* Highlight on hover/focus */
             color: var(--pico-primary-inverse); /* Ensure text is visible on hover */
             outline: none; /* Remove default focus outline if needed */
        }
        /* --- Style for the footnote definition link (back arrow) --- */
        #final-report-content .footnotes li p a {
             text-decoration: none;
             color: var(--pico-primary);
        }
        #final-report-content .footnotes li p a:hover {
            text-decoration: underline;
        }
        /* --- Style for the footnote list itself --- */
        #final-report-content .footnotes {
             margin-top: 2.5em; /* More space before footnotes */
             padding-top: 1.5em; /* More space inside the footnotes section */
             border-top: 2px solid var(--pico-primary-focus); /* More prominent top border */
             font-size: 0.9em;
             line-height: 1.6; /* Improve readability */
        }
        #final-report-content .footnotes ol { padding-left: 20px; }
        #final-report-content .footnotes li { margin-bottom: 0.75em; } /* More space between items */
        #final-report-content .footnotes li:target {
             background-color: var(--pico-primary-focus); /* Highlight target footnote */
             border-radius: var(--pico-border-radius);
             outline: 1px solid var(--pico-primary);
             /* Add a small transition */
             transition: background-color 0.3s ease-in-out;
        }
        #error-container { margin-top: 1.5rem; }
        #error-container article { border-color: var(--pico-form-invalid-border-color); background-color: var(--pico-form-invalid-background-color); }
        #error-container header { color: var(--pico-form-invalid-color); }
        article[aria-busy="true"]::before {
           width: 2rem;
           height: 2rem;
        }
        /* --- Style for download form --- */
        #download-form {
            margin-top: 1.5rem;
            padding: 1rem;
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            background-color: var(--pico-contrast-hover);
        }
    </style>
</head>
<body>
    <main class="container">
        <hgroup>
            <h1>Research Progress</h1>
            <!-- Display the original, unencoded topic -->
            <h2>Topic: {{ topic|e }}</h2> <!-- Use original topic, escape it -->
        </hgroup>
        <a href="/" role="button" class="secondary outline">Start New Research</a>
        <hr>

        <!-- Progress Area -->
        <article id="progress-area" aria-busy="true">
            <h3>Live Progress Log</h3>
            <div id="progress-log-container">
                <ul id="progress-log">
                    <li>Initializing research process...</li>
                </ul>
            </div>

            <!-- Streaming Output Area -->
            <div id="synthesis-stream-container" class="stream-container">
                <h4>Synthesizing Information (Live)...</h4>
                <pre id="synthesis-stream-content"></pre>
            </div>
            <div id="report-stream-container" class="stream-container">
                <h4>Generating Report (Live)...</h4>
                <pre id="report-stream-content"></pre>
            </div>
        </article>

        <!-- Error Display Area -->
        <div id="error-container" style="display: none;">
            <article>
                <header><strong>An Error Occurred</strong></header>
                <p id="error-message"></p>
            </article>
        </div>

        <!-- Final Report Area -->
        <section id="final-report-container" style="display: none;">
             <hr>
            <h2>Final Research Report</h2>

            <!-- Download Form -->
            <form id="download-form" action="/download_docx" method="post" style="display: none;">
                 <p>Download the report:</p>
                 <!-- Hidden field to store raw Markdown -->
                 <textarea name="markdown_report" id="raw-markdown-report" style="display: none;"></textarea>
                 <!-- Hidden field for topic (used for filename) -->
                 <input type="hidden" name="topic" value="{{ topic|e }}">
                 <button type="submit" id="download-docx-button">Download as DOCX</button>
                 <!-- --- MODIFIED: Corrected library name in message --- -->
                 <small id="docx-unavailable-msg" style="display: none; color: var(--pico-muted-color); margin-left: 1rem;">DOCX download requires the 'html2docx' library on the server.</small>
            </form>

            <div id="final-report-content">
                <!-- Report HTML will be injected here -->
            </div>
             <details style="margin-top: 2rem;">
                 <summary>Raw Scraped Data Snippet (Debug)</summary>
                 <pre id="scraped-preview" style="font-size: 0.8em; background: var(--pico-contrast); max-height: 200px; overflow-y: auto;">Not available.</pre>
             </details>
        </section>

        <hr style="margin-top: 30px;">
        <a href="/" role="button" class="secondary outline">Start New Research</a>
    </main>

    <script>
        const progressLog = document.getElementById('progress-log');
        const progressLogContainer = document.getElementById('progress-log-container');
        const progressArea = document.getElementById('progress-area');
        const finalReportContainer = document.getElementById('final-report-container');
        const finalReportContent = document.getElementById('final-report-content');
        const errorContainer = document.getElementById('error-container');
        const errorMessage = document.getElementById('error-message');
        const scrapedPreview = document.getElementById('scraped-preview');

        // Stream containers and content elements
        const synthesisStreamContainer = document.getElementById('synthesis-stream-container');
        const synthesisStreamContent = document.getElementById('synthesis-stream-content');
        const reportStreamContainer = document.getElementById('report-stream-container');
        const reportStreamContent = document.getElementById('report-stream-content');

        // Download elements
        const downloadForm = document.getElementById('download-form');
        const downloadDocxButton = document.getElementById('download-docx-button');
        const docxUnavailableMsg = document.getElementById('docx-unavailable-msg');
        const rawMarkdownReport = document.getElementById('raw-markdown-report');

        // Get the URL-encoded topic passed from Flask
        const encodedTopic = "{{ encoded_topic|e }}"; // Still need encoded for SSE URL
        const displayTopic = "{{ topic|e }}"; // Use original for display/forms

        let currentStreamTarget = null;

        function addProgress(message, isError = false) {
            const li = document.createElement('li');
            // Basic sanitization (replace < >) - avoid complex HTML injection from progress messages
            li.textContent = message.replace(/</g, "<").replace(/>/g, ">");
            if (isError) {
                li.classList.add('error');
            }
            progressLog.insertBefore(li, progressLog.firstChild);
            progressLogContainer.scrollTop = 0;
        }

        function handleStreamChunk(content, target) {
            let targetEl;
            let targetContainer;
            if (target === 'synthesis') {
                targetEl = synthesisStreamContent;
                targetContainer = synthesisStreamContainer;
                synthesisStreamContainer.style.display = 'block';
            } else if (target === 'report') {
                targetEl = reportStreamContent;
                targetContainer = reportStreamContainer;
                reportStreamContainer.style.display = 'block';
            } else {
                return;
            }
            targetEl.textContent += content;
            targetContainer.scrollTop = targetContainer.scrollHeight;
        }

        // Establish SSE connection using the encoded topic
        const params = new URLSearchParams({ topic: encodedTopic });
        const eventSource = new EventSource(`/stream?${params.toString()}`);

        eventSource.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);

                switch (data.type) {
                    case 'progress':
                        addProgress(`[${new Date().toLocaleTimeString()}] ${data.message}`);
                        break;
                    case 'error':
                        const errorMsgText = `ERROR: ${data.message}`;
                        addProgress(errorMsgText, true);
                        errorMessage.textContent = errorMsgText;
                        errorContainer.style.display = 'block';
                        progressArea.removeAttribute('aria-busy');
                        // Don't close eventSource on all errors, maybe recoverable
                        break;
                    case 'stream_start':
                         currentStreamTarget = data.target;
                         addProgress(`AI starting to generate: ${currentStreamTarget}...`);
                         if (currentStreamTarget === 'synthesis') {
                             synthesisStreamContent.textContent = '';
                             synthesisStreamContainer.style.display = 'block';
                         }
                         if (currentStreamTarget === 'report') {
                             reportStreamContent.textContent = '';
                             reportStreamContainer.style.display = 'block';
                         }
                         break;
                    case 'llm_chunk':
                         if (currentStreamTarget === data.target) {
                            handleStreamChunk(data.content, data.target);
                         }
                         break;
                    case 'complete':
                        // --- ADDED CONSOLE LOGS HERE ---
                        console.log("Received 'complete' event data:", data);
                        console.log("Checking data.docx_available:", data.docx_available);
                        // -----------------------------

                        addProgress("Research process complete.");
                        progressArea.removeAttribute('aria-busy');
                        finalReportContent.innerHTML = data.report_html;

                        // Handle download section
                        if (data.report_markdown) {
                            rawMarkdownReport.value = data.report_markdown; // Store raw markdown
                            if (data.docx_available) {
                                downloadForm.style.display = 'block'; // Show download form
                                downloadDocxButton.disabled = false;
                                docxUnavailableMsg.style.display = 'none';
                            } else {
                                // html2docx not available on server
                                downloadForm.style.display = 'block'; // Still show section
                                downloadDocxButton.disabled = true; // Disable button
                                // --- MODIFIED: Ensure correct message is displayed ---
                                docxUnavailableMsg.style.display = 'inline'; // Show warning
                            }
                        } else {
                            addProgress("No final report markdown received.", true);
                            downloadForm.style.display = 'none'; // Hide form if no markdown
                        }

                        if (data.raw_scraped_data_preview) {
                           scrapedPreview.textContent = data.raw_scraped_data_preview;
                        } else {
                           scrapedPreview.textContent = "Not available.";
                        }
                        finalReportContainer.style.display = 'block'; // Show report section

                        eventSource.close(); // Research is done, close connection
                        break;
                    case 'stream_terminated': // Added to handle graceful close from server finally block
                        addProgress("Server stream terminated.", false);
                        progressArea.removeAttribute('aria-busy');
                        if (eventSource) eventSource.close();
                        break;
                }
            } catch (e) {
                console.error("Error parsing SSE data:", e, "Raw data:", event.data); // Log raw data on error
                addProgress("Error processing update from server.", true);
            }
        };

        eventSource.onerror = function(err) {
            console.error("EventSource failed:", err);
            if (eventSource.readyState === EventSource.CLOSED) {
                 addProgress("Server connection closed.", false);
            } else if (eventSource.readyState === EventSource.CONNECTING) {
                 addProgress("Connection lost, attempting to reconnect...", true);
                 // No need to display the big error message yet, browser might reconnect
            } else {
                const errorMsg = "Connection to server lost or failed unexpectedly. Please try starting new research.";
                addProgress(errorMsg, true);
                errorMessage.textContent = errorMsg;
                errorContainer.style.display = 'block';
                progressArea.removeAttribute('aria-busy');
                if (eventSource) eventSource.close(); // Close definitively on unrecoverable error
            }
        };

        window.addEventListener('beforeunload', () => {
            if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
                console.log("Closing EventSource connection on page unload.");
                eventSource.close();
            }
        });

    </script>
</body>
</html>