<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Results for "{{ topic }}"</title>
    <link rel="stylesheet" href="{{ pico_css }}">
    <!-- Link the custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='custom.css') }}">
    <style>
        /* Add minor inline styles if needed, e.g., for layout */
        body { padding-bottom: 5rem; }
        .progress-log, #report-container, #final-report-display { margin-top: 1.5rem; } /* Applied consistent margin */
        #progress-list { max-height: 300px; overflow-y: auto; background-color: --pico-code-background-color; padding: 10px; border-radius: 5px; font-size: 0.9em; list-style: none; /* Remove bullets */ padding-left: 10px; }
        #progress-list li { margin-bottom: 5px; word-wrap: break-word; border-left: 3px solid #ccc; padding-left: 8px; }
        #progress-list li.error { color: red; font-weight: bold; border-left-color: red; }
        #progress-list li.fatal-error { color: darkred; font-weight: bold; border-left-color: darkred; }
        /* Style for report/synthesis sections before content arrives */
        #synthesis-output, #report-output {
            min-height: 100px; /* Placeholder height */
            padding: 1rem;
            border: 1px dashed var(--pico-muted-border-color);
            margin-bottom: 1rem;
            white-space: pre-wrap; /* Keep whitespace formatting for streaming */
            word-wrap: break-word;
            background-color: var(--pico-code-background-color); /* Use code block bg */
            font-family: var(--pico-font-family); /* Use standard font */
            font-size: 0.95em;
        }
        #raw-data-preview {
            background-color: #2d2d2d; /* Dark background */
            color: #f0f0f0; /* Light text */
            padding: 1rem;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.85em;
            max-height: 400px;
            overflow: auto;
            white-space: pre-wrap;
            word-wrap: break-word; /* Allow long lines (like URLs) to wrap */
        }
        #download-buttons button { margin-right: 0.5rem; margin-bottom: 0.5rem; /* Add bottom margin for wrap */ }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid var(--pico-primary); border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block; margin-left: 10px; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none; }
    </style>
</head>
<body>
    <main class="container">
        <nav aria-label="breadcrumb">
            <ul>
                <li><a href="{{ url_for('index') }}">New Research</a></li>
                <li>Research Results</li>
            </ul>
        </nav>
        <article> <!-- Wrap main content in article for semantic HTML & Pico styling -->
            <header>
                <h1>Researching: "{{ topic }}"</h1>
                <p>Please wait while the research is being conducted. Progress updates will appear below.</p>
            </header>

            <section id="progress-section">
                <h2>Progress Log <span id="loader" class="loader"></span></h2>
                <ul id="progress-list">
                    <li>Initializing...</li>
                </ul>
            </section>

            <section id="report-container" class="hidden">
                <hr>
                <h2>Live Synthesis Output</h2>
                <p><em>Synthesizing information from sources... (Content will stream below)</em></p>
                <div id="synthesis-output" aria-live="polite">Waiting for synthesis stream...</div>

                <h2>Live Report Generation</h2>
                <p><em>Generating the final report... (Content will stream below)</em></p>
                <div id="report-output" aria-live="polite">Waiting for report stream...</div>
            </section>

            <section id="final-report-display" class="hidden">
                <hr>
                <h2>Final Research Report</h2>
                <!-- This div will hold the final, styled report HTML -->
                <div id="report-display">
                    <!-- Report HTML will be injected here by JavaScript -->
                    <p><em>Loading final report...</em></p>
                </div>

                <div id="final-actions" style="margin-top: 2rem;">
                     <h3>Downloads & Raw Data</h3>
                     <div id="download-buttons">
                         <form id="download-md-form" style="display: inline;">
                             <button type="button" id="download-md-button" disabled>Copy Markdown</button>
                         </form>
                         <form id="download-docx-form" action="{{ url_for('download_docx') }}" method="post" style="display: inline;" class="hidden">
                             <input type="hidden" name="markdown_report" id="hidden-markdown-report">
                             <input type="hidden" name="topic" value="{{ topic }}">
                             <button type="submit" id="download-docx-button" disabled>Download DOCX</button>
                         </form>
                         <span id="docx-disabled-msg" style="font-size: 0.8em; margin-left: 5px;" class="hidden"> (DOCX download disabled: server missing 'html2docx' library)</span>
                     </div>
                     <details style="margin-top: 1.5rem;">
                        <summary>View Raw Scraped Data Preview</summary>
                        <pre id="raw-data-preview">Loading raw data preview...</pre>
                     </details>
                </div>
            </section>
        </article> <!-- End article wrap -->

    </main>

    <!-- Include the custom JS -->
    <script src="{{ url_for('static', filename='results.js') }}"></script>
    <script>
        // Ensure variables are declared correctly, prefer const/let
        const encodedTopic = "{{ encoded_topic | e }}"; // Use Flask's 'e' filter for safety
        const progressList = document.getElementById('progress-list');
        const loader = document.getElementById('loader');
        const reportContainer = document.getElementById('report-container');
        const finalReportDisplay = document.getElementById('final-report-display');
        const reportDisplayDiv = document.getElementById('report-display'); // Target for final HTML
        const synthesisOutput = document.getElementById('synthesis-output');
        const reportOutput = document.getElementById('report-output');
        const rawDataPreview = document.getElementById('raw-data-preview');
        const downloadMdButton = document.getElementById('download-md-button');
        const downloadDocxForm = document.getElementById('download-docx-form');
        const downloadDocxButton = document.getElementById('download-docx-button');
        const hiddenMarkdownReport = document.getElementById('hidden-markdown-report');
        const docxDisabledMsg = document.getElementById('docx-disabled-msg');


        let finalMarkdownContent = ""; // Store final raw markdown
        let eventSource = null; // Declare eventSource variable

        function addProgress(message, isError = false, isFatal = false) {
            const li = document.createElement('li');
            // Sanitize message slightly - prevent basic HTML injection in logs
            li.textContent = message;
            if (isFatal) {
                 li.classList.add('fatal-error');
            } else if (isError) {
                li.classList.add('error');
            }
            progressList.appendChild(li);
            // Auto-scroll to the bottom
            progressList.scrollTop = progressList.scrollHeight;
        }

        function connectSSE() {
            // --- SSE Connection ---
            if (eventSource) {
                eventSource.close(); // Close existing connection if any
            }
            console.log(`Connecting to SSE stream at /stream?topic=${encodedTopic}`);
            eventSource = new EventSource(`/stream?topic=${encodedTopic}`);

            eventSource.onopen = function() {
                console.log("SSE connection opened.");
                progressList.innerHTML = ''; // Clear initializing message
                addProgress("Connection established. Starting research process...");
                reportContainer.classList.remove('hidden'); // Show streaming areas
                synthesisOutput.textContent = ""; // Clear placeholders
                reportOutput.textContent = "";
                loader.classList.remove('hidden'); // Ensure loader is visible
            };

            eventSource.onmessage = function(event) {
                // console.log("SSE message received:", event.data); // Debugging
                try {
                    const eventData = JSON.parse(event.data);

                    switch (eventData.type) {
                        case 'progress':
                            addProgress(eventData.message);
                            break;
                        case 'error':
                            addProgress(eventData.message, true, eventData.fatal || false);
                            if (eventData.fatal) {
                                addProgress("Research stopped due to fatal error.", true, true);
                                loader.classList.add('hidden'); // Hide loader on fatal error
                                if(eventSource) eventSource.close(); // Close connection on fatal error
                            }
                            break;
                        case 'stream_start':
                            if (eventData.target === 'synthesis') {
                                synthesisOutput.textContent = ""; // Clear "Waiting..." message
                                addProgress("Starting LLM synthesis stream...");
                            } else if (eventData.target === 'report') {
                                reportOutput.textContent = ""; // Clear "Waiting..." message
                                addProgress("Starting LLM report generation stream...");
                            }
                            break;
                        case 'llm_chunk':
                            // Append chunks to the respective live output areas
                            const targetElement = eventData.target === 'synthesis' ? synthesisOutput : reportOutput;
                            targetElement.textContent += eventData.content;
                            // Basic auto-scroll for live areas (optional)
                            // targetElement.scrollTop = targetElement.scrollHeight;
                            break;
                        case 'complete':
                            addProgress("Research complete. Processing final results...");
                            reportContainer.classList.add('hidden'); // Hide live streaming areas
                            finalReportDisplay.classList.remove('hidden'); // Show final report area

                            // Inject the final *HTML* report into the display div
                            reportDisplayDiv.innerHTML = eventData.report_html || "<p><em>Error: Received empty report HTML.</em></p>";

                            // Store the raw *Markdown* for copy/download
                            finalMarkdownContent = eventData.report_markdown || "";
                            hiddenMarkdownReport.value = finalMarkdownContent; // Set for DOCX form

                            // Display raw data preview
                            rawDataPreview.textContent = eventData.raw_scraped_data_preview || "No raw data preview available.";

                            // Enable download buttons
                            downloadMdButton.disabled = !finalMarkdownContent; // Enable only if content exists
                            if (eventData.docx_available && finalMarkdownContent) {
                                downloadDocxForm.classList.remove('hidden');
                                downloadDocxButton.disabled = false;
                                docxDisabledMsg.classList.add('hidden');
                            } else {
                                downloadDocxForm.classList.add('hidden'); // Ensure it's hidden if not available
                                downloadDocxButton.disabled = true;
                                if (!eventData.docx_available) {
                                     docxDisabledMsg.classList.remove('hidden');
                                }
                            }

                            // *** IMPORTANT: Call the tooltip function AFTER HTML is injected ***
                            if (typeof addCitationTooltips === 'function') {
                                addCitationTooltips();
                            } else {
                                console.error("addCitationTooltips function not found!");
                            }

                            addProgress("Final report displayed. Process finished.");
                            loader.classList.add('hidden');
                            if(eventSource) eventSource.close(); // Close connection on normal completion
                            break;
                        case 'stream_terminated':
                            // This signal means the server stream has ended, regardless of success/failure
                            addProgress("Server stream terminated.", false);
                            loader.classList.add('hidden');
                            if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
                                eventSource.close();
                            }
                            // If the final report hasn't been shown yet (e.g., due to error before 'complete')
                            if (finalReportDisplay.classList.contains('hidden')) {
                                addProgress("Process stopped before completion. Check logs for errors.", true);
                            }
                            break;
                        default:
                            console.warn("Received unknown SSE event type:", eventData.type);
                    }
                } catch (e) {
                    console.error("Error parsing SSE message or processing event:", e);
                    addProgress(`Client-side error processing update: ${e.message}`, true);
                    // Avoid adding the raw data if parsing failed
                    // addProgress(`Raw data: ${event.data}`, true);
                }
            };

            eventSource.onerror = function(error) {
                console.error("SSE connection error:", error);
                addProgress("Error connecting to the research stream. Please check the server or try again.", true, true);
                loader.classList.add('hidden'); // Hide loader on connection error
                if(eventSource) eventSource.close();
                // Hide streaming areas if they were shown, indicate failure
                reportContainer.classList.add('hidden');
                if (finalReportDisplay.classList.contains('hidden')) { // Only if not already completed
                    addProgress("Could not complete research due to connection failure.", true, true);
                }
                 // Disable buttons on error
                 downloadMdButton.disabled = true;
                 downloadDocxButton.disabled = true;
                 downloadDocxForm.classList.add('hidden');
            };
        }

        // --- Button Actions ---
        downloadMdButton.addEventListener('click', () => {
            if (finalMarkdownContent && navigator.clipboard) { // Check for clipboard API support
                navigator.clipboard.writeText(finalMarkdownContent)
                    .then(() => {
                        addProgress("Report Markdown copied to clipboard.");
                        // Optional: Change button text temporarily
                        const originalText = downloadMdButton.textContent;
                        downloadMdButton.textContent = "Copied!";
                        downloadMdButton.disabled = true; // Briefly disable after copy
                        setTimeout(() => {
                             downloadMdButton.textContent = originalText;
                             downloadMdButton.disabled = false;
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy markdown: ', err);
                        addProgress("Failed to copy Markdown automatically. Please copy manually.", true);
                        // Consider showing the markdown in a modal or textarea here as a fallback
                    });
            } else if (!navigator.clipboard) {
                 addProgress("Clipboard API not supported by your browser. Cannot copy automatically.", true);
            }
             else {
                addProgress("No final report content available to copy.", true);
            }
        });

        // --- Initial Setup ---
        // Start the SSE connection when the page loads
        connectSSE();

    </script>
</body>
</html>