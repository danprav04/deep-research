<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Results: {{ topic }}</title>
    <link rel="stylesheet" href="{{ pico_css }}">
    <style>
        body { padding-bottom: 5rem; }
        main { margin-top: 1rem; }
        #progressUpdates {
            background-color: var(--card-background-color);
            border: 1px solid var(--card-border-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1.5rem;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.4;
        }
        #progressUpdates p {
            margin-bottom: 0.5em;
            word-wrap: break-word;
        }
        #progressUpdates p:last-child {
            margin-bottom: 0;
        }
        .error-message {
            color: var(--color-invalid);
            font-weight: bold;
        }
        .fatal-error {
             background-color: var(--color-invalid-background);
             border-left: 5px solid var(--color-invalid);
             padding: 0.8rem;
        }
        #resultsContainer article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            border: 1px solid var(--card-border-color);
            border-radius: var(--border-radius);
            background-color: var(--card-background-color);
        }
        #reportDisplay h1, #reportDisplay h2, #reportDisplay h3 {
             margin-top: 1.5em;
             margin-bottom: 0.8em;
        }
        #reportDisplay p {
            line-height: 1.6;
        }
        #reportDisplay .footnote-ref a, #reportDisplay .footnote-backref {
            text-decoration: none;
            padding: 0.1em 0.3em;
            background-color: var(--muted-border-color);
            border-radius: var(--border-radius);
            font-weight: bold;
            color: var(--primary-focus);
             transition: background-color 0.2s ease;
        }
        #reportDisplay .footnote-ref a:hover, #reportDisplay .footnote-backref:hover {
             background-color: var(--primary-hover);
             color: var(--primary-inverse);
        }
         /* Style for the target footnote when linked */
        #reportDisplay .footnotes li:target {
            background-color: var(--mark-background-color);
            border-left: 3px solid var(--mark-color);
            padding-left: 0.5rem; /* Adjust as needed */
            margin-left: -0.8rem; /* Compensate for padding */
            border-radius: var(--border-radius);
        }
        #rawDataDisplay {
            font-family: monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            background-color: var(--code-background-color); /* Use code block background */
            color: var(--code-color); /* Use code text color */
            padding: 1rem;
            border-radius: var(--border-radius);
        }
        #loadingIndicator { text-align: center; margin: 2rem 0; }
        #downloadSection { margin-top: 1.5rem; }
        /* Hide elements initially */
        #resultsContainer, #downloadSection, #rawDataAccordion { display: none; }
    </style>
</head>
<body>
    <main class="container">
        <hgroup>
            <h1>Research Results</h1>
            <h2>Topic: {{ topic }}</h2>
        </hgroup>

        <article id="progressCard">
            <header><strong>Progress Updates</strong></header>
            <div id="progressUpdates">
                <p>Connecting to research stream...</p>
            </div>
            <div id="loadingIndicator">
                <progress indeterminate></progress>
                <p>Research in progress...</p>
            </div>
        </article>

        <section id="resultsContainer">
             <!-- Synthesis Section -->
             <details id="synthesisAccordion">
                <summary><h2>Intermediate Synthesis</h2> (LLM analysis of sources)</summary>
                <article id="synthesisDisplay">
                    <p>Waiting for synthesis stream...</p>
                </article>
            </details>

            <!-- Final Report Section -->
            <article id="reportDisplay">
                <h2>Final Report</h2>
                <p>Waiting for report generation...</p>
                <!-- Final HTML report will be injected here -->
            </article>

             <!-- Raw Data Section -->
             <details id="rawDataAccordion">
                <summary><h3>Raw Scraped Data Preview</h3></summary>
                <article>
                     <pre><code id="rawDataDisplay">(Raw data preview will appear here)</code></pre>
                </article>
            </details>
        </section>

        <section id="downloadSection">
            <h3>Download Report</h3>
            <form id="downloadForm" action="{{ url_for('download_docx') }}" method="post" style="display: none;">
                 <input type="hidden" name="markdown_report" id="hiddenMarkdownReport">
                 <input type="hidden" name="topic" value="{{ topic }}">
                 <button type="submit" id="downloadDocxButton" disabled>Download as DOCX</button>
                 <small id="docxError" class="error-message"></small>
                 <small id="docxUnavailable" style="display: none;"> (DOCX conversion library not installed on server)</small>
            </form>
            <button id="copyMarkdownButton">Copy Report Markdown</button>
             <small id="copyStatus" style="display: none; margin-left: 10px;"></small>
        </section>

    </main>

    <script>
        const progressUpdates = document.getElementById('progressUpdates');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const resultsContainer = document.getElementById('resultsContainer');
        const synthesisDisplay = document.getElementById('synthesisDisplay');
        const reportDisplay = document.getElementById('reportDisplay');
        const rawDataDisplay = document.getElementById('rawDataDisplay');
        const synthesisAccordion = document.getElementById('synthesisAccordion');
        const rawDataAccordion = document.getElementById('rawDataAccordion');
        const downloadSection = document.getElementById('downloadSection');
        const downloadForm = document.getElementById('downloadForm');
        const downloadDocxButton = document.getElementById('downloadDocxButton');
        const hiddenMarkdownReport = document.getElementById('hiddenMarkdownReport');
        const docxError = document.getElementById('docxError');
        const docxUnavailable = document.getElementById('docxUnavailable');
        const copyMarkdownButton = document.getElementById('copyMarkdownButton');
        const copyStatus = document.getElementById('copyStatus');

        let finalReportMarkdownContent = ""; // Store the final markdown
        let docxReady = false;

        // --- SSE Connection ---
        const encodedTopic = "{{ encoded_topic }}"; // Get encoded topic from Flask
        const eventSource = new EventSource(`/stream?topic=${encodedTopic}`);

        eventSource.onopen = function() {
            addProgress("Connection established. Starting research...");
        };

        eventSource.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                // console.log("SSE Data:", data); // Debugging

                switch (data.type) {
                    case 'progress':
                        addProgress(data.message);
                        break;
                    case 'error':
                        addProgress(`Error: ${data.message}`, true, data.fatal);
                        if (data.fatal) {
                            eventSource.close();
                            loadingIndicator.innerHTML = '<p class="error-message">Research stopped due to fatal error.</p>';
                        }
                        break;
                    case 'stream_start':
                        if (data.target === 'synthesis') {
                            synthesisDisplay.innerHTML = ''; // Clear initial message
                        } else if (data.target === 'report') {
                            reportDisplay.innerHTML = ''; // Clear initial message
                        }
                        break;
                    case 'llm_chunk':
                         // Append chunks carefully - Avoid full re-render on each chunk
                        if (data.target === 'synthesis') {
                            // For synthesis, simple append might be okay, but could parse markdown later
                            // Consider using a library like Marked.js if real-time markdown preview is needed
                             const chunkText = document.createTextNode(data.content);
                             synthesisDisplay.appendChild(chunkText);
                             synthesisAccordion.style.display = 'block'; // Show accordion if hidden
                        } else if (data.target === 'report') {
                            // For the final report, we append markdown and convert *once* at the end
                            // For now, just show the raw streaming text - will be replaced by HTML
                             const chunkText = document.createTextNode(data.content);
                             reportDisplay.appendChild(chunkText);
                        }
                        break;
                    case 'complete':
                        resultsContainer.style.display = 'block'; // Show results section
                        synthesisAccordion.style.display = 'block'; // Ensure synthesis is visible
                        rawDataAccordion.style.display = 'block'; // Show raw data accordion

                        // Final Report Display (using HTML from server)
                        reportDisplay.innerHTML = data.report_html;
                        finalReportMarkdownContent = data.report_markdown; // Store markdown
                        hiddenMarkdownReport.value = finalReportMarkdownContent; // Set for form

                        // Raw Data Preview
                        rawDataDisplay.textContent = data.raw_scraped_data_preview || '(No raw data preview available)';

                        // Download Section
                        downloadSection.style.display = 'block';
                        if (data.docx_available) {
                            downloadForm.style.display = 'inline-block'; // Show form if available
                            downloadDocxButton.disabled = false;
                            docxReady = true;
                        } else {
                            docxUnavailable.style.display = 'inline'; // Show unavailable message
                            docxReady = false;
                        }

                        loadingIndicator.style.display = 'none'; // Hide loading indicator
                         addProgress("Research process completed.", false); // Final status message
                        eventSource.close(); // Close connection
                        break;
                     case 'stream_terminated':
                        console.log("Stream terminated by server.");
                        loadingIndicator.style.display = 'none'; // Hide loading indicator if not already hidden
                        if (!resultsContainer.style.display || resultsContainer.style.display === 'none') {
                           addProgress("Stream ended unexpectedly.", true); // Indicate if completion wasn't reached
                        }
                        eventSource.close();
                        break;
                    default:
                        console.warn("Received unknown SSE event type:", data.type);
                }
            } catch (e) {
                console.error("Failed to parse SSE message or update UI:", e);
                addProgress("Error processing update from server.", true);
            }
             scrollToBottom(progressUpdates); // Keep progress visible
        };

        eventSource.onerror = function(err) {
            console.error("EventSource failed:", err);
            addProgress("Connection to research stream lost or failed.", true);
            loadingIndicator.innerHTML = '<p class="error-message">Connection Error. Please try again.</p>';
            eventSource.close();
        };

        // --- Helper Functions ---
        function addProgress(message, isError = false, isFatal = false) {
            const p = document.createElement('p');
            p.textContent = message;
            if (isError) {
                p.classList.add('error-message');
                 if (isFatal) {
                     p.classList.add('fatal-error'); // Add specific class for fatal errors
                 }
            }
            progressUpdates.appendChild(p);
            scrollToBottom(progressUpdates); // Scroll down
        }

        function scrollToBottom(element) {
             // Only scroll if user isn't scrolled up
             if (element.scrollHeight - element.scrollTop <= element.clientHeight + 50) {
                 element.scrollTop = element.scrollHeight;
             }
        }

         // --- Interactive Footnotes ---
         // Use event delegation on the report display area
         reportDisplay.addEventListener('click', function(event) {
             const target = event.target;

             // Check if the click is on a footnote reference link (e.g., [^1])
             if (target.matches('.footnote-ref a') || target.closest('.footnote-ref a')) {
                 event.preventDefault(); // Prevent default jump
                 const link = target.closest('.footnote-ref a');
                 const targetId = link.getAttribute('href'); // Should be like #fn1
                 const footnoteElement = document.querySelector(targetId);
                 if (footnoteElement) {
                     footnoteElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                     // Optional: Add temporary highlight (handled by CSS :target)
                 }
             }
             // Check if the click is on a footnote back reference link (e.g., ↩)
             else if (target.matches('.footnote-backref') || target.closest('.footnote-backref')) {
                  event.preventDefault(); // Prevent default jump
                  const link = target.closest('.footnote-backref');
                  const targetId = link.getAttribute('href'); // Should be like #fnref1
                  const refElement = document.querySelector(targetId);
                  if (refElement) {
                       refElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  }
             }
         });


        // --- Download & Copy Buttons ---
        downloadForm.addEventListener('submit', function(e) {
            if (!docxReady) {
                e.preventDefault(); // Prevent submission if DOCX not available/ready
                docxError.textContent = 'DOCX generation is not available.';
                return;
            }
            // Add a small delay or loading indicator if needed
            downloadDocxButton.textContent = 'Preparing...';
            downloadDocxButton.disabled = true;
             // Reset button after a short delay allows download to initiate
             setTimeout(() => {
                 downloadDocxButton.textContent = 'Download as DOCX';
                 downloadDocxButton.disabled = false;
             }, 3000);
        });

         copyMarkdownButton.addEventListener('click', async () => {
             if (!finalReportMarkdownContent) {
                 showCopyStatus('No report content available to copy.', true);
                 return;
             }
             try {
                 await navigator.clipboard.writeText(finalReportMarkdownContent);
                 showCopyStatus('Markdown copied to clipboard!', false);
             } catch (err) {
                 console.error('Failed to copy markdown: ', err);
                 showCopyStatus('Failed to copy. See console for details.', true);
                 // Fallback for older browsers (less reliable)
                 try {
                     const textArea = document.createElement("textarea");
                     textArea.value = finalReportMarkdownContent;
                     textArea.style.position = "fixed"; // Avoid scrolling
                     textArea.style.left = "-9999px";
                     document.body.appendChild(textArea);
                     textArea.focus();
                     textArea.select();
                     document.execCommand('copy');
                     document.body.removeChild(textArea);
                     showCopyStatus('Markdown copied (fallback method)!', false);
                 } catch (fallbackErr) {
                    console.error('Fallback copy failed: ', fallbackErr);
                     showCopyStatus('Copy failed. Manual copy needed.', true);
                 }
             }
         });

         function showCopyStatus(message, isError = false) {
             copyStatus.textContent = message;
             copyStatus.style.color = isError ? 'var(--color-invalid)' : 'var(--color-valid)';
             copyStatus.style.display = 'inline';
             setTimeout(() => {
                 copyStatus.style.display = 'none';
             }, 3000); // Hide after 3 seconds
         }

    </script>
</body>
</html>